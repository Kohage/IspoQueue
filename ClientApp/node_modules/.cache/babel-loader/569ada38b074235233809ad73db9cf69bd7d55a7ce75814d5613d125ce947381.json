{"ast":null,"code":"\"use client\";\n\nimport _slicedToArray from \"G:/Diplom/IspoQueue/ClientApp/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport * as React from 'react';\nimport toArray from \"rc-util/es/Children/toArray\";\nimport useLayoutEffect from \"rc-util/es/hooks/useLayoutEffect\";\nvar MeasureText = /*#__PURE__*/React.forwardRef(function (_ref, ref) {\n  var style = _ref.style,\n    children = _ref.children;\n  var spanRef = React.useRef(null);\n  React.useImperativeHandle(ref, function () {\n    return {\n      isExceed: function isExceed() {\n        var span = spanRef.current;\n        return span.scrollHeight > span.clientHeight;\n      },\n      getHeight: function getHeight() {\n        return spanRef.current.clientHeight;\n      }\n    };\n  });\n  return /*#__PURE__*/React.createElement(\"span\", {\n    \"aria-hidden\": true,\n    ref: spanRef,\n    style: Object.assign({\n      position: 'fixed',\n      display: 'block',\n      left: 0,\n      top: 0,\n      pointerEvents: 'none',\n      backgroundColor: 'rgba(255, 0, 0, 0.65)'\n    }, style)\n  }, children);\n});\nfunction cuttable(node) {\n  var type = typeof node;\n  return type === 'string' || type === 'number';\n}\nfunction getNodesLen(nodeList) {\n  var totalLen = 0;\n  nodeList.forEach(function (node) {\n    if (cuttable(node)) {\n      totalLen += String(node).length;\n    } else {\n      totalLen += 1;\n    }\n  });\n  return totalLen;\n}\nfunction sliceNodes(nodeList, len) {\n  var currLen = 0;\n  var currentNodeList = [];\n  for (var i = 0; i < nodeList.length; i += 1) {\n    // Match to return\n    if (currLen === len) {\n      return currentNodeList;\n    }\n    var node = nodeList[i];\n    var canCut = cuttable(node);\n    var nodeLen = canCut ? String(node).length : 1;\n    var nextLen = currLen + nodeLen;\n    // Exceed but current not which means we need cut this\n    // This will not happen on validate ReactElement\n    if (nextLen > len) {\n      var restLen = len - currLen;\n      currentNodeList.push(String(node).slice(0, restLen));\n      return currentNodeList;\n    }\n    currentNodeList.push(node);\n    currLen = nextLen;\n  }\n  return nodeList;\n}\n// Measure for the `text` is exceed the `rows` or not\nvar STATUS_MEASURE_NONE = 0;\nvar STATUS_MEASURE_START = 1;\nvar STATUS_MEASURE_NEED_ELLIPSIS = 2;\nvar STATUS_MEASURE_NO_NEED_ELLIPSIS = 3;\nvar lineClipStyle = {\n  display: '-webkit-box',\n  overflow: 'hidden',\n  WebkitBoxOrient: 'vertical'\n};\nexport default function EllipsisMeasure(props) {\n  var enableMeasure = props.enableMeasure,\n    width = props.width,\n    text = props.text,\n    children = props.children,\n    rows = props.rows,\n    expanded = props.expanded,\n    miscDeps = props.miscDeps,\n    onEllipsis = props.onEllipsis;\n  var nodeList = React.useMemo(function () {\n    return toArray(text);\n  }, [text]);\n  var nodeLen = React.useMemo(function () {\n    return getNodesLen(nodeList);\n  }, [text]);\n  // ========================= Full Content =========================\n  // Used for measure only, which means it's always render as no need ellipsis\n  var fullContent = React.useMemo(function () {\n    return children(nodeList, false);\n  }, [text]);\n  // ========================= Cut Content ==========================\n  var _React$useState = React.useState(null),\n    _React$useState2 = _slicedToArray(_React$useState, 2),\n    ellipsisCutIndex = _React$useState2[0],\n    setEllipsisCutIndex = _React$useState2[1];\n  var cutMidRef = React.useRef(null);\n  // ========================= NeedEllipsis =========================\n  var needEllipsisRef = React.useRef(null);\n  // Measure for `rows-1` height, to avoid operation exceed the line height\n  var descRowsEllipsisRef = React.useRef(null);\n  var symbolRowEllipsisRef = React.useRef(null);\n  var _React$useState3 = React.useState(false),\n    _React$useState4 = _slicedToArray(_React$useState3, 2),\n    canEllipsis = _React$useState4[0],\n    setCanEllipsis = _React$useState4[1];\n  var _React$useState5 = React.useState(STATUS_MEASURE_NONE),\n    _React$useState6 = _slicedToArray(_React$useState5, 2),\n    needEllipsis = _React$useState6[0],\n    setNeedEllipsis = _React$useState6[1];\n  var _React$useState7 = React.useState(0),\n    _React$useState8 = _slicedToArray(_React$useState7, 2),\n    ellipsisHeight = _React$useState8[0],\n    setEllipsisHeight = _React$useState8[1];\n  // Trigger start measure\n  useLayoutEffect(function () {\n    if (enableMeasure && width && nodeLen) {\n      setNeedEllipsis(STATUS_MEASURE_START);\n    } else {\n      setNeedEllipsis(STATUS_MEASURE_NONE);\n    }\n  }, [width, text, rows, enableMeasure, nodeList]);\n  // Measure process\n  useLayoutEffect(function () {\n    var _a, _b, _c, _d;\n    if (needEllipsis === STATUS_MEASURE_START) {\n      var isOverflow = !!((_a = needEllipsisRef.current) === null || _a === void 0 ? void 0 : _a.isExceed());\n      setNeedEllipsis(isOverflow ? STATUS_MEASURE_NEED_ELLIPSIS : STATUS_MEASURE_NO_NEED_ELLIPSIS);\n      setEllipsisCutIndex(isOverflow ? [0, nodeLen] : null);\n      setCanEllipsis(isOverflow);\n      // Get the basic height of ellipsis rows\n      var baseRowsEllipsisHeight = ((_b = needEllipsisRef.current) === null || _b === void 0 ? void 0 : _b.getHeight()) || 0;\n      // Get the height of `rows - 1` + symbol height\n      var descRowsEllipsisHeight = rows === 1 ? 0 : ((_c = descRowsEllipsisRef.current) === null || _c === void 0 ? void 0 : _c.getHeight()) || 0;\n      var symbolRowEllipsisHeight = ((_d = symbolRowEllipsisRef.current) === null || _d === void 0 ? void 0 : _d.getHeight()) || 0;\n      var rowsWithEllipsisHeight = descRowsEllipsisHeight + symbolRowEllipsisHeight;\n      var maxRowsHeight = Math.max(baseRowsEllipsisHeight, rowsWithEllipsisHeight);\n      setEllipsisHeight(maxRowsHeight + 1);\n      onEllipsis(isOverflow);\n    }\n  }, [needEllipsis]);\n  // ========================= Cut Measure ==========================\n  var cutMidIndex = ellipsisCutIndex ? Math.ceil((ellipsisCutIndex[0] + ellipsisCutIndex[1]) / 2) : 0;\n  useLayoutEffect(function () {\n    var _a;\n    var _ref2 = ellipsisCutIndex || [0, 0],\n      _ref3 = _slicedToArray(_ref2, 2),\n      minIndex = _ref3[0],\n      maxIndex = _ref3[1];\n    if (minIndex !== maxIndex) {\n      var midHeight = ((_a = cutMidRef.current) === null || _a === void 0 ? void 0 : _a.getHeight()) || 0;\n      var isOverflow = midHeight > ellipsisHeight;\n      var targetMidIndex = cutMidIndex;\n      if (maxIndex - minIndex === 1) {\n        targetMidIndex = isOverflow ? minIndex : maxIndex;\n      }\n      if (isOverflow) {\n        setEllipsisCutIndex([minIndex, targetMidIndex]);\n      } else {\n        setEllipsisCutIndex([targetMidIndex, maxIndex]);\n      }\n    }\n  }, [ellipsisCutIndex, cutMidIndex]);\n  // ========================= Text Content =========================\n  var finalContent = React.useMemo(function () {\n    if (needEllipsis !== STATUS_MEASURE_NEED_ELLIPSIS || !ellipsisCutIndex || ellipsisCutIndex[0] !== ellipsisCutIndex[1]) {\n      var content = children(nodeList, false);\n      // Limit the max line count to avoid scrollbar blink\n      // https://github.com/ant-design/ant-design/issues/42958\n      if (needEllipsis !== STATUS_MEASURE_NO_NEED_ELLIPSIS && needEllipsis !== STATUS_MEASURE_NONE) {\n        return /*#__PURE__*/React.createElement(\"span\", {\n          style: Object.assign(Object.assign({}, lineClipStyle), {\n            WebkitLineClamp: rows\n          })\n        }, content);\n      }\n      return content;\n    }\n    return children(expanded ? nodeList : sliceNodes(nodeList, ellipsisCutIndex[0]), canEllipsis);\n  }, [expanded, needEllipsis, ellipsisCutIndex, nodeList].concat(_toConsumableArray(miscDeps)));\n  // ============================ Render ============================\n  var measureStyle = {\n    width: width,\n    whiteSpace: 'normal',\n    margin: 0,\n    padding: 0\n  };\n  return /*#__PURE__*/React.createElement(React.Fragment, null, finalContent, needEllipsis === STATUS_MEASURE_START && ( /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(MeasureText, {\n    style: Object.assign(Object.assign(Object.assign({}, measureStyle), lineClipStyle), {\n      WebkitLineClamp: rows\n    }),\n    ref: needEllipsisRef\n  }, fullContent), /*#__PURE__*/React.createElement(MeasureText, {\n    style: Object.assign(Object.assign(Object.assign({}, measureStyle), lineClipStyle), {\n      WebkitLineClamp: rows - 1\n    }),\n    ref: descRowsEllipsisRef\n  }, fullContent), /*#__PURE__*/React.createElement(MeasureText, {\n    style: Object.assign(Object.assign(Object.assign({}, measureStyle), lineClipStyle), {\n      WebkitLineClamp: 1\n    }),\n    ref: symbolRowEllipsisRef\n  }, children([], true)))), needEllipsis === STATUS_MEASURE_NEED_ELLIPSIS && ellipsisCutIndex && ellipsisCutIndex[0] !== ellipsisCutIndex[1] && ( /*#__PURE__*/React.createElement(MeasureText, {\n    style: Object.assign(Object.assign({}, measureStyle), {\n      top: 400\n    }),\n    ref: cutMidRef\n  }, children(sliceNodes(nodeList, cutMidIndex), true))));\n}","map":{"version":3,"names":["_slicedToArray","_toConsumableArray","React","toArray","useLayoutEffect","MeasureText","forwardRef","_ref","ref","style","children","spanRef","useRef","useImperativeHandle","isExceed","span","current","scrollHeight","clientHeight","getHeight","createElement","Object","assign","position","display","left","top","pointerEvents","backgroundColor","cuttable","node","type","getNodesLen","nodeList","totalLen","forEach","String","length","sliceNodes","len","currLen","currentNodeList","i","canCut","nodeLen","nextLen","restLen","push","slice","STATUS_MEASURE_NONE","STATUS_MEASURE_START","STATUS_MEASURE_NEED_ELLIPSIS","STATUS_MEASURE_NO_NEED_ELLIPSIS","lineClipStyle","overflow","WebkitBoxOrient","EllipsisMeasure","props","enableMeasure","width","text","rows","expanded","miscDeps","onEllipsis","useMemo","fullContent","_React$useState","useState","_React$useState2","ellipsisCutIndex","setEllipsisCutIndex","cutMidRef","needEllipsisRef","descRowsEllipsisRef","symbolRowEllipsisRef","_React$useState3","_React$useState4","canEllipsis","setCanEllipsis","_React$useState5","_React$useState6","needEllipsis","setNeedEllipsis","_React$useState7","_React$useState8","ellipsisHeight","setEllipsisHeight","_a","_b","_c","_d","isOverflow","baseRowsEllipsisHeight","descRowsEllipsisHeight","symbolRowEllipsisHeight","rowsWithEllipsisHeight","maxRowsHeight","Math","max","cutMidIndex","ceil","_ref2","_ref3","minIndex","maxIndex","midHeight","targetMidIndex","finalContent","content","WebkitLineClamp","concat","measureStyle","whiteSpace","margin","padding","Fragment"],"sources":["G:/Diplom/IspoQueue/clientapp/node_modules/antd/es/typography/Base/Ellipsis.js"],"sourcesContent":["\"use client\";\n\nimport _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport * as React from 'react';\nimport toArray from \"rc-util/es/Children/toArray\";\nimport useLayoutEffect from \"rc-util/es/hooks/useLayoutEffect\";\nconst MeasureText = /*#__PURE__*/React.forwardRef((_ref, ref) => {\n  let {\n    style,\n    children\n  } = _ref;\n  const spanRef = React.useRef(null);\n  React.useImperativeHandle(ref, () => ({\n    isExceed: () => {\n      const span = spanRef.current;\n      return span.scrollHeight > span.clientHeight;\n    },\n    getHeight: () => spanRef.current.clientHeight\n  }));\n  return /*#__PURE__*/React.createElement(\"span\", {\n    \"aria-hidden\": true,\n    ref: spanRef,\n    style: Object.assign({\n      position: 'fixed',\n      display: 'block',\n      left: 0,\n      top: 0,\n      pointerEvents: 'none',\n      backgroundColor: 'rgba(255, 0, 0, 0.65)'\n    }, style)\n  }, children);\n});\nfunction cuttable(node) {\n  const type = typeof node;\n  return type === 'string' || type === 'number';\n}\nfunction getNodesLen(nodeList) {\n  let totalLen = 0;\n  nodeList.forEach(node => {\n    if (cuttable(node)) {\n      totalLen += String(node).length;\n    } else {\n      totalLen += 1;\n    }\n  });\n  return totalLen;\n}\nfunction sliceNodes(nodeList, len) {\n  let currLen = 0;\n  const currentNodeList = [];\n  for (let i = 0; i < nodeList.length; i += 1) {\n    // Match to return\n    if (currLen === len) {\n      return currentNodeList;\n    }\n    const node = nodeList[i];\n    const canCut = cuttable(node);\n    const nodeLen = canCut ? String(node).length : 1;\n    const nextLen = currLen + nodeLen;\n    // Exceed but current not which means we need cut this\n    // This will not happen on validate ReactElement\n    if (nextLen > len) {\n      const restLen = len - currLen;\n      currentNodeList.push(String(node).slice(0, restLen));\n      return currentNodeList;\n    }\n    currentNodeList.push(node);\n    currLen = nextLen;\n  }\n  return nodeList;\n}\n// Measure for the `text` is exceed the `rows` or not\nconst STATUS_MEASURE_NONE = 0;\nconst STATUS_MEASURE_START = 1;\nconst STATUS_MEASURE_NEED_ELLIPSIS = 2;\nconst STATUS_MEASURE_NO_NEED_ELLIPSIS = 3;\nconst lineClipStyle = {\n  display: '-webkit-box',\n  overflow: 'hidden',\n  WebkitBoxOrient: 'vertical'\n};\nexport default function EllipsisMeasure(props) {\n  const {\n    enableMeasure,\n    width,\n    text,\n    children,\n    rows,\n    expanded,\n    miscDeps,\n    onEllipsis\n  } = props;\n  const nodeList = React.useMemo(() => toArray(text), [text]);\n  const nodeLen = React.useMemo(() => getNodesLen(nodeList), [text]);\n  // ========================= Full Content =========================\n  // Used for measure only, which means it's always render as no need ellipsis\n  const fullContent = React.useMemo(() => children(nodeList, false), [text]);\n  // ========================= Cut Content ==========================\n  const [ellipsisCutIndex, setEllipsisCutIndex] = React.useState(null);\n  const cutMidRef = React.useRef(null);\n  // ========================= NeedEllipsis =========================\n  const needEllipsisRef = React.useRef(null);\n  // Measure for `rows-1` height, to avoid operation exceed the line height\n  const descRowsEllipsisRef = React.useRef(null);\n  const symbolRowEllipsisRef = React.useRef(null);\n  const [canEllipsis, setCanEllipsis] = React.useState(false);\n  const [needEllipsis, setNeedEllipsis] = React.useState(STATUS_MEASURE_NONE);\n  const [ellipsisHeight, setEllipsisHeight] = React.useState(0);\n  // Trigger start measure\n  useLayoutEffect(() => {\n    if (enableMeasure && width && nodeLen) {\n      setNeedEllipsis(STATUS_MEASURE_START);\n    } else {\n      setNeedEllipsis(STATUS_MEASURE_NONE);\n    }\n  }, [width, text, rows, enableMeasure, nodeList]);\n  // Measure process\n  useLayoutEffect(() => {\n    var _a, _b, _c, _d;\n    if (needEllipsis === STATUS_MEASURE_START) {\n      const isOverflow = !!((_a = needEllipsisRef.current) === null || _a === void 0 ? void 0 : _a.isExceed());\n      setNeedEllipsis(isOverflow ? STATUS_MEASURE_NEED_ELLIPSIS : STATUS_MEASURE_NO_NEED_ELLIPSIS);\n      setEllipsisCutIndex(isOverflow ? [0, nodeLen] : null);\n      setCanEllipsis(isOverflow);\n      // Get the basic height of ellipsis rows\n      const baseRowsEllipsisHeight = ((_b = needEllipsisRef.current) === null || _b === void 0 ? void 0 : _b.getHeight()) || 0;\n      // Get the height of `rows - 1` + symbol height\n      const descRowsEllipsisHeight = rows === 1 ? 0 : ((_c = descRowsEllipsisRef.current) === null || _c === void 0 ? void 0 : _c.getHeight()) || 0;\n      const symbolRowEllipsisHeight = ((_d = symbolRowEllipsisRef.current) === null || _d === void 0 ? void 0 : _d.getHeight()) || 0;\n      const rowsWithEllipsisHeight = descRowsEllipsisHeight + symbolRowEllipsisHeight;\n      const maxRowsHeight = Math.max(baseRowsEllipsisHeight, rowsWithEllipsisHeight);\n      setEllipsisHeight(maxRowsHeight + 1);\n      onEllipsis(isOverflow);\n    }\n  }, [needEllipsis]);\n  // ========================= Cut Measure ==========================\n  const cutMidIndex = ellipsisCutIndex ? Math.ceil((ellipsisCutIndex[0] + ellipsisCutIndex[1]) / 2) : 0;\n  useLayoutEffect(() => {\n    var _a;\n    const [minIndex, maxIndex] = ellipsisCutIndex || [0, 0];\n    if (minIndex !== maxIndex) {\n      const midHeight = ((_a = cutMidRef.current) === null || _a === void 0 ? void 0 : _a.getHeight()) || 0;\n      const isOverflow = midHeight > ellipsisHeight;\n      let targetMidIndex = cutMidIndex;\n      if (maxIndex - minIndex === 1) {\n        targetMidIndex = isOverflow ? minIndex : maxIndex;\n      }\n      if (isOverflow) {\n        setEllipsisCutIndex([minIndex, targetMidIndex]);\n      } else {\n        setEllipsisCutIndex([targetMidIndex, maxIndex]);\n      }\n    }\n  }, [ellipsisCutIndex, cutMidIndex]);\n  // ========================= Text Content =========================\n  const finalContent = React.useMemo(() => {\n    if (needEllipsis !== STATUS_MEASURE_NEED_ELLIPSIS || !ellipsisCutIndex || ellipsisCutIndex[0] !== ellipsisCutIndex[1]) {\n      const content = children(nodeList, false);\n      // Limit the max line count to avoid scrollbar blink\n      // https://github.com/ant-design/ant-design/issues/42958\n      if (needEllipsis !== STATUS_MEASURE_NO_NEED_ELLIPSIS && needEllipsis !== STATUS_MEASURE_NONE) {\n        return /*#__PURE__*/React.createElement(\"span\", {\n          style: Object.assign(Object.assign({}, lineClipStyle), {\n            WebkitLineClamp: rows\n          })\n        }, content);\n      }\n      return content;\n    }\n    return children(expanded ? nodeList : sliceNodes(nodeList, ellipsisCutIndex[0]), canEllipsis);\n  }, [expanded, needEllipsis, ellipsisCutIndex, nodeList].concat(_toConsumableArray(miscDeps)));\n  // ============================ Render ============================\n  const measureStyle = {\n    width,\n    whiteSpace: 'normal',\n    margin: 0,\n    padding: 0\n  };\n  return /*#__PURE__*/React.createElement(React.Fragment, null, finalContent, needEllipsis === STATUS_MEASURE_START && ( /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(MeasureText, {\n    style: Object.assign(Object.assign(Object.assign({}, measureStyle), lineClipStyle), {\n      WebkitLineClamp: rows\n    }),\n    ref: needEllipsisRef\n  }, fullContent), /*#__PURE__*/React.createElement(MeasureText, {\n    style: Object.assign(Object.assign(Object.assign({}, measureStyle), lineClipStyle), {\n      WebkitLineClamp: rows - 1\n    }),\n    ref: descRowsEllipsisRef\n  }, fullContent), /*#__PURE__*/React.createElement(MeasureText, {\n    style: Object.assign(Object.assign(Object.assign({}, measureStyle), lineClipStyle), {\n      WebkitLineClamp: 1\n    }),\n    ref: symbolRowEllipsisRef\n  }, children([], true)))), needEllipsis === STATUS_MEASURE_NEED_ELLIPSIS && ellipsisCutIndex && ellipsisCutIndex[0] !== ellipsisCutIndex[1] && ( /*#__PURE__*/React.createElement(MeasureText, {\n    style: Object.assign(Object.assign({}, measureStyle), {\n      top: 400\n    }),\n    ref: cutMidRef\n  }, children(sliceNodes(nodeList, cutMidIndex), true))));\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}